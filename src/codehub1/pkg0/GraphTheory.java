/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package codehub1.pkg0;

/**
 *
 * @author Aaman
 */
public class GraphTheory extends javax.swing.JFrame {

    /**
     * Creates new form GraphTheory
     */
    public GraphTheory() {
        initComponents();
        setResizable(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        output = new javax.swing.JTextArea();
        bpm = new javax.swing.JButton();
        bellman = new javax.swing.JButton();
        floyd = new javax.swing.JButton();
        kruskal = new javax.swing.JButton();
        prims = new javax.swing.JButton();
        topSort = new javax.swing.JButton();
        dfs = new javax.swing.JButton();
        bfs = new javax.swing.JButton();
        dijkstra = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));

        jButton1.setBackground(new java.awt.Color(255, 0, 0));
        jButton1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jButton1.setForeground(new java.awt.Color(255, 255, 255));
        jButton1.setText("Back");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(204, 51, 0));
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Graph Theory");

        output.setEditable(false);
        output.setBackground(new java.awt.Color(0, 0, 0));
        output.setColumns(20);
        output.setFont(new java.awt.Font("Monospaced", 1, 14)); // NOI18N
        output.setForeground(new java.awt.Color(255, 255, 255));
        output.setRows(5);
        output.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        jScrollPane2.setViewportView(output);

        bpm.setBackground(new java.awt.Color(0, 0, 51));
        bpm.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        bpm.setForeground(new java.awt.Color(255, 255, 255));
        bpm.setText("Bipartite Matching");
        bpm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bpmActionPerformed(evt);
            }
        });

        bellman.setBackground(new java.awt.Color(0, 0, 51));
        bellman.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        bellman.setForeground(new java.awt.Color(255, 255, 255));
        bellman.setText("Bellman Ford");
        bellman.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bellmanActionPerformed(evt);
            }
        });

        floyd.setBackground(new java.awt.Color(0, 0, 51));
        floyd.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        floyd.setForeground(new java.awt.Color(255, 255, 255));
        floyd.setText("Floyd Warshall");
        floyd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                floydActionPerformed(evt);
            }
        });

        kruskal.setBackground(new java.awt.Color(0, 0, 51));
        kruskal.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        kruskal.setForeground(new java.awt.Color(255, 255, 255));
        kruskal.setText("Kruskal");
        kruskal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                kruskalActionPerformed(evt);
            }
        });

        prims.setBackground(new java.awt.Color(0, 0, 51));
        prims.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        prims.setForeground(new java.awt.Color(255, 255, 255));
        prims.setText("Prims");
        prims.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                primsActionPerformed(evt);
            }
        });

        topSort.setBackground(new java.awt.Color(0, 0, 51));
        topSort.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        topSort.setForeground(new java.awt.Color(255, 255, 255));
        topSort.setText("Topological Sort");
        topSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topSortActionPerformed(evt);
            }
        });

        dfs.setBackground(new java.awt.Color(0, 0, 51));
        dfs.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        dfs.setForeground(new java.awt.Color(255, 255, 255));
        dfs.setText("DFS");
        dfs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                dfsActionPerformed(evt);
            }
        });

        bfs.setBackground(new java.awt.Color(0, 0, 51));
        bfs.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        bfs.setForeground(new java.awt.Color(255, 255, 255));
        bfs.setText("BFS");
        bfs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bfsActionPerformed(evt);
            }
        });

        dijkstra.setBackground(new java.awt.Color(0, 0, 51));
        dijkstra.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        dijkstra.setForeground(new java.awt.Color(255, 255, 255));
        dijkstra.setText("Dijkstra");
        dijkstra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                dijkstraActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 215, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(dfs, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(bfs, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(dijkstra, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(bellman, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(floyd, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(bpm, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(kruskal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(prims, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(topSort, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 610, Short.MAX_VALUE)
                        .addComponent(jButton1)
                        .addContainerGap())
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 647, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 62, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(dfs)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(bfs)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(dijkstra)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(bellman)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(floyd)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(bpm, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(kruskal)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(prims)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(topSort))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 437, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(57, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        new FrontPage().setVisible(true);
        dispose();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void dfsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_dfsActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"using namespace std;\n" +
"const int mx = 1005;\n" +
"int N,E;\n" +
"bool vis[mx];\n" +
"vector < int > adj[mx];\n" +
"void DFS(int src)\n" +
"{\n" +
"    vis[src] = 1;\n" +
"    cout << src << endl;\n" +
"    for(auto i : adj[src])\n" +
"    {\n" +
"        if(!vis[i])\n" +
"            DFS(i);\n" +
"    }\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    int u,v;\n" +
"    cin >> N >> E;\n" +
"    for(int i=0;i<E;i++)\n" +
"    {\n" +
"        cin >> u >> v;\n" +
"        adj[u].push_back(v);\n" +
"        adj[v].push_back(u);\n" +
"    }\n" +
"    DFS(1);\n" +
"}");
    }//GEN-LAST:event_dfsActionPerformed

    private void bfsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bfsActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"using namespace std;\n" +
"vector < int > A[100];\n" +
"int v,e;\n" +
"bool visited[100];\n" +
"queue < int > B;\n" +
"void Input()\n" +
"{\n" +
"    int a,b;\n" +
"    cout << \"Enter number of vertices and edges\\n\";\n" +
"    cin >> v >> e;\n" +
"    cout << \"Enter the Graph's connections\\n\";\n" +
"    for(int i=1;i<=e;i++)\n" +
"    {\n" +
"        cin >> a >> b;\n" +
"        A[a].push_back(b);\n" +
"        A[b].push_back(a);\n" +
"    }\n" +
"}\n" +
"void bfs(int start)\n" +
"{\n" +
"    visited[start] = true;\n" +
"    B.push(start);\n" +
"    while(!B.empty())\n" +
"    {\n" +
"        int n = B.front();\n" +
"        B.pop();\n" +
"        cout << n << endl;\n" +
"        for(int i=0;i<A[n].size();i++)\n" +
"        {\n" +
"            int x = A[n][i];\n" +
"            if(!visited[x])\n" +
"            {\n" +
"                B.push(x);\n" +
"                visited[x] = true;\n" +
"            }\n" +
"        }\n" +
"    }\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    Input();\n" +
"    int start;\n" +
"    cout << \"Enter the value of starting point : \";\n" +
"    cin >> start;\n" +
"    cout << endl;\n" +
"    bfs(start);\n" +
"}");
    }//GEN-LAST:event_bfsActionPerformed

    private void dijkstraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_dijkstraActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"#define pii pair<int,int>\n" +
"using namespace std;\n" +
"const int mx = 1e5+5;\n" +
"vector < pii > cost[mx];\n" +
"int vis[mx],par[mx],dist[mx],N,E;\n" +
"bool dijkstra(int st,int en)\n" +
"{\n" +
"    priority_queue< pii,vector<pii>,greater<pii> > pq;\n" +
"    for(int i=1;i<=N;i++)\n" +
"        dist[i] = INFINITY;\n" +
"    pq.push(pii(0,st));\n" +
"    par[st] = -1;\n" +
"    dist[st] = 0;\n" +
"    while(!pq.empty())\n" +
"    {\n" +
"        int h = pq.top().second;\n" +
"        pq.pop();\n" +
"        if(h==en)\n" +
"            return true;\n" +
"        vis[h] = 1;\n" +
"        for(auto i : cost[h])\n" +
"        {\n" +
"            int w = i.second , v = i.first;\n" +
"            if(!vis[v] && dist[h]+w<dist[v])\n" +
"            {\n" +
"                dist[v] = dist[h]+w;\n" +
"                pq.push(pii(dist[v],v));\n" +
"                par[v] = h;\n" +
"            }\n" +
"        }\n" +
"    }\n" +
"    return false;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    int u,v,w;\n" +
"    cin >> N >> E;\n" +
"    for(int i=0;i<E;i++)\n" +
"    {\n" +
"        cin >> u >> v >> w;\n" +
"        cost[u].push_back(pii(v,w));\n" +
"        cost[v].push_back(pii(u,w));\n" +
"    }\n" +
"    if(dijkstra(1,N))\n" +
"    {\n" +
"        vector < int > path;\n" +
"        int i = N;\n" +
"        while(i!=-1)\n" +
"        {\n" +
"            path.push_back(i);\n" +
"            i = par[i];\n" +
"        }\n" +
"        for(int i=path.size()-1;i>=0;i--)\n" +
"            cout << path[i] << \" \";\n" +
"        cout << endl;\n" +
"    }\n" +
"    else\n" +
"        cout << -1 << endl;\n" +
"}");
    }//GEN-LAST:event_dijkstraActionPerformed

    private void bellmanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bellmanActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"using namespace std;\n" +
"struct edge\n" +
"{\n" +
"    int u,v,w;\n" +
"    edge(int _u,int _v,int _w)\n" +
"    {\n" +
"        u = _u;\n" +
"        v = _v;\n" +
"        w = _w;\n" +
"    }\n" +
"};\n" +
"const int MAX = 1e5+7 , INF = 1e7+7;\n" +
"vector < edge > adj;\n" +
"long long dist[MAX];\n" +
"int par[MAX];\n" +
"int V,E;\n" +
"void bellman_ford(int src)\n" +
"{\n" +
"    for(int i=1;i<=V;i++)\n" +
"        dist[i] = INF;\n" +
"    dist[src] = 0;\n" +
"    par[src] = -1;\n" +
"    for(int i=1;i<V;i++)\n" +
"    {\n" +
"        int flag = 0;\n" +
"        for(auto j : adj)\n" +
"        {\n" +
"            if(dist[j.v] > dist[j.u]+j.w)\n" +
"            {\n" +
"                dist[j.v] = dist[j.u]+j.w;\n" +
"                par[j.v] = j.u;\n" +
"                flag = 1;\n" +
"            }\n" +
"        }\n" +
"        if(!flag)\n" +
"            break;\n" +
"    }\n" +
"}\n" +
"void print_path(int src,int node)\n" +
"{\n" +
"    vector < int > path;\n" +
"    int i = node;\n" +
"    while(i!=-1)\n" +
"    {\n" +
"        path.push_back(i);\n" +
"        i = par[i];\n" +
"    }\n" +
"    for(i=path.size()-1;i>=0;i--)\n" +
"        cout << path[i] << \" \";\n" +
"    cout << endl;\n" +
"}\n" +
"bool negetive_cycle(int src)\n" +
"{\n" +
"    bellman_ford(src);\n" +
"    for(auto i : adj)\n" +
"    {\n" +
"        if(dist[i.v] > dist[i.u]+i.w)\n" +
"        {\n" +
"            return true;\n" +
"        }\n" +
"    }\n" +
"    return false;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    ios_base::sync_with_stdio(false);cin.tie(NULL);\n" +
"    int uu,vv,ww;\n" +
"    cin >> V >> E;\n" +
"    for(int i=0;i<E;i++)\n" +
"    {\n" +
"        cin >> uu >> vv >> ww;\n" +
"        adj.push_back(edge(uu,vv,ww));\n" +
"    }\n" +
"    if(negetive_cycle(1))\n" +
"        cout << \"Negetive Cycle is found!!\\n\";\n" +
"    else if(dist[V]<INF)\n" +
"        print_path(1,V);\n" +
"    else\n" +
"        cout << -1 << endl;\n" +
"}");
    }//GEN-LAST:event_bellmanActionPerformed

    private void floydActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_floydActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"using namespace std;\n" +
"const int mx = 1005 , inf = INFINITY;\n" +
"int N,E;\n" +
"int adj[mx][mx],path[mx][mx];\n" +
"void floydWarsh()\n" +
"{\n" +
"    for(int k=1; k<=N; k++)\n" +
"    {\n" +
"        for(int i=1; i<=N; i++)\n" +
"        {\n" +
"            for(int j=1; j<=N; j++)\n" +
"            {\n" +
"                if(adj[i][j]>adj[i][k]+adj[k][j] && adj[i][k]!=inf && adj[k][j]!=inf)\n" +
"                {\n" +
"                    adj[i][j] = adj[i][k]+adj[k][j];\n" +
"                    path[i][j] = path[i][k];\n" +
"                }\n" +
"            }\n" +
"        }\n" +
"    }\n" +
"}\n" +
"void findPath(int i,int j)\n" +
"{\n" +
"    vector < int > vec;\n" +
"    while(i!=j)\n" +
"    {\n" +
"        if(i==-1)\n" +
"        {\n" +
"            cout << \"No Path Found!!\\n\";\n" +
"            return;\n" +
"        }\n" +
"        vec.push_back(i);\n" +
"        i = path[i][j];\n" +
"    }\n" +
"    vec.push_back(i);\n" +
"    cout << \"Path : \";\n" +
"    for(auto i:vec)\n" +
"    {\n" +
"        cout << i << \"->\";\n" +
"    }\n" +
"    cout << endl;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    int u,v,w;\n" +
"    cin >> N >> E;\n" +
"    for(int i=1; i<=N; i++)\n" +
"    {\n" +
"        for(int j=1; j<=N; j++)\n" +
"        {\n" +
"            path[i][j] = -1;\n" +
"            adj[i][j] = inf;\n" +
"        }\n" +
"    }\n" +
"    for(int i=1; i<=N; i++)\n" +
"        adj[i][i] = 0, path[i][i] = i;\n" +
" \n" +
"    for(int i=0; i<E; i++)\n" +
"    {\n" +
"        cin >> u >> v >> w;\n" +
"        adj[u][v] = w;\n" +
"        path[u][v] = v;\n" +
"    }\n" +
"    floydWarsh();\n" +
"    while(1)\n" +
"    {\n" +
"        int a,b;\n" +
"        cin >> a >> b;\n" +
"        findPath(a,b);\n" +
"        cout << \"Distance : \" << adj[a][b] << endl;\n" +
"    }\n" +
"}");
    }//GEN-LAST:event_floydActionPerformed

    private void bpmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bpmActionPerformed
        // TODO add your handling code here:
        output.setText("Problem Link : http://lightoj.com/volume_showproblem.php?problem=1184\n" +
"Solution Code :\n\n#include<bits/stdc++.h>\n" +
"#define ll long long\n" +
"using namespace std;\n" +
"struct Info\n" +
"{\n" +
"    int h,a,s;\n" +
"};\n" +
"int m,n;\n" +
"Info men[55] , women[55];\n" +
"vector < int > adj[55];\n" +
"int match[100];\n" +
"bool vis[55];\n" +
"int dfs(int y)\n" +
"{\n" +
"    for(int i=0;i<adj[y].size();i++)\n" +
"    {\n" +
"        int z = adj[y][i];\n" +
"        if(vis[z])\n" +
"            continue;\n" +
"        vis[z] = 1;\n" +
"        if(match[z] == -1 || dfs(match[z]))\n" +
"        {\n" +
"            match[z] = y;\n" +
"            return 1;\n" +
"        }\n" +
"    }\n" +
"    return 0;\n" +
"}\n" +
"void BPM()\n" +
"{\n" +
"    memset(match , -1 , sizeof match);\n" +
"    int total = 0;\n" +
"    for(int i=0;i<m;i++)\n" +
"    {\n" +
"        if(adj[i].empty())\n" +
"            continue;\n" +
"        memset(vis,0,sizeof vis);\n" +
"        if(dfs(i))\n" +
"            total++;\n" +
"    }\n" +
"    cout << total << endl;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    ios_base::sync_with_stdio(false);cin.tie(NULL);\n" +
"    int t,x,y,z,cas=1;\n" +
"    cin >> t;\n" +
"    while(t--)\n" +
"    {\n" +
"        cin >> m >> n;\n" +
"        for(int i=0;i<m;i++)\n" +
"        {\n" +
"            cin >> x >> y >> z;\n" +
"            men[i].h = x;\n" +
"            men[i].a = y;\n" +
"            men[i].s = z;\n" +
"        }\n" +
"        for(int i=0;i<n;i++)\n" +
"        {\n" +
"            cin >> x >> y >> z;\n" +
"            women[i].h = x;\n" +
"            women[i].a = y;\n" +
"            women[i].s = z;\n" +
"  \n" +
"            for(int j=0;j<m;j++)\n" +
"            {\n" +
"                if(abs(men[j].h-women[i].h)<=12 && abs(men[j].a-women[i].a)<=5 && !(men[j].s^women[i].s))\n" +
"                    adj[j].push_back(i);\n" +
"            }\n" +
"        }\n" +
"        cout << \"Case \" << cas++ << \": \";\n" +
"        BPM();\n" +
"        for(int i=0;i<=55;i++)\n" +
"            adj[i].clear();\n" +
"        memset(men,0,sizeof men);\n" +
"        memset(women,0,sizeof women);\n" +
"    }\n" +
"}");
    }//GEN-LAST:event_bpmActionPerformed

    private void kruskalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_kruskalActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"#define pii pair<int,int>\n" +
"using namespace std;\n" +
"const int mx = 1005;\n" +
"struct edge\n" +
"{\n" +
"    int u,v,w;\n" +
" \n" +
"};\n" +
"vector < edge > adj;\n" +
"int N,E,par[mx];\n" +
"bool cmp(edge a,edge b)\n" +
"{\n" +
"    return a.w < b.w;\n" +
"}\n" +
"int Find(int n)\n" +
"{\n" +
"    if(par[n]==n)\n" +
"        return n;\n" +
"    return par[n] = Find(par[n]);\n" +
"}\n" +
"int kruskal()\n" +
"{\n" +
"    int ans = 0 , cnt = 0 , uu , vv;\n" +
"    for(int i=1;i<=N;i++)\n" +
"        par[i] = i;\n" +
"    for(int i=0; i<E; i++)\n" +
"    {\n" +
"        uu = Find(adj[i].u) , vv = Find(adj[i].v);\n" +
"        if(uu!=vv)\n" +
"        {\n" +
"            par[uu] = vv;\n" +
"            cnt++;\n" +
"            ans += adj[i].w;\n" +
"            if(cnt==N-1)\n" +
"                break;\n" +
"        }\n" +
"    }\n" +
"    return ans;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    int uu,vv,ww;\n" +
"    edge get;\n" +
"    cin >> N >> E;\n" +
"    for(int i=0; i<E; i++)\n" +
"    {\n" +
"        cin >> uu >> vv >> ww;\n" +
"        get.u = uu;\n" +
"        get.v = vv;\n" +
"        get.w = ww;\n" +
"        adj.push_back(get);\n" +
"    }\n" +
"    sort(adj.begin(),adj.end(),cmp);\n" +
"    cout << kruskal() << endl;\n" +
"}");
    }//GEN-LAST:event_kruskalActionPerformed

    private void primsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_primsActionPerformed
        // TODO add your handling code here:
        output.setText("#include<bits/stdc++.h>\n" +
"#define pii pair<int,int>\n" +
"using namespace std;\n" +
"const int MAX = 100005;\n" +
"struct node\n" +
"{\n" +
"    int u,w;\n" +
"    node(){}\n" +
"    node(int _u,int _w)\n" +
"    {\n" +
"        u = _u;\n" +
"        w = _w;\n" +
"    }\n" +
"};\n" +
"bool operator<(node a,node b)\n" +
"{\n" +
"    return a.w > b.w;\n" +
"}\n" +
"int cost[MAX],vis[MAX],n,e;\n" +
"priority_queue<node> pq;\n" +
"vector < pii > adj[MAX];\n" +
"int prim(int src)\n" +
"{\n" +
"    for(int i=1;i<=n;i++)\n" +
"        cost[i] = INFINITY;\n" +
"    int ans = 0;\n" +
"    cost[src] = 0;\n" +
"    pq.push(node(src,cost[src]));\n" +
"    while(!pq.empty())\n" +
"    {\n" +
"        node temp = pq.top();\n" +
"        pq.pop();\n" +
"        if(vis[temp.u])\n" +
"            continue;\n" +
"        vis[temp.u] = 1;\n" +
"        ans += temp.w;\n" +
"        for(auto v : adj[temp.u])\n" +
"        {\n" +
"            if(vis[v.first])\n" +
"                continue;\n" +
"            else if(v.second < cost[v.first])\n" +
"            {\n" +
"                cost[v.first] = v.second;\n" +
"                pq.push(node(v.first,v.second));\n" +
"            }\n" +
"        }\n" +
"    }\n" +
"    return ans;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    cin >> n >> e;\n" +
"    int u,v,w;\n" +
"    for(int i=0;i<e;i++)\n" +
"    {\n" +
"        cin >> u >> v >> w;\n" +
"        adj[u].push_back(pii(v,w));\n" +
"        adj[v].push_back(pii(u,w));\n" +
"    }\n" +
"    cout << \"Minimum Cost : \" << prim(1) << endl;\n" +
"}");
    }//GEN-LAST:event_primsActionPerformed

    private void topSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topSortActionPerformed
        // TODO add your handling code here:
        output.setText("Topological Sort with DFS :\n\n#include<bits/stdc++.h>\n" +
"using namespace std;\n" +
"const int MAX = 105;\n" +
"vector < int > adj[MAX];\n" +
"int node,edge,flag=0;\n" +
"int visited[MAX];\n" +
"vector < int > ans;\n" +
"void topSort_DFS(int src)\n" +
"{\n" +
"    if(visited[src]==1)\n" +
"    {\n" +
"        cout << \"There is cycle in this graph.TopSort can't be performed\\n\";\n" +
"        ans.clear();\n" +
"        flag = 1;\n" +
"        return;\n" +
"    }\n" +
"    visited[src] = 1;\n" +
"    for(int i=0;i<adj[src].size();i++)\n" +
"    {\n" +
"        if(visited[adj[src][i]]!=2)\n" +
"            topSort_DFS(adj[src][i]);\n" +
"    }\n" +
"    if(!flag)\n" +
"        ans.push_back(src);\n" +
"    visited[src] = 2;\n" +
"}\n" +
"int main()\n" +
"{\n" +
"    int u,v;\n" +
"    cout << \"Enter the number of nodes & edges : \";\n" +
"    cin >> node >> edge;\n" +
"    for(int i=0;i<edge;i++)\n" +
"    {\n" +
"       cin >> u >> v;\n" +
"       adj[u].push_back(v);\n" +
"    }\n" +
"    for(int i=1;i<=node;i++)\n" +
"    {\n" +
"        if(!visited[i])\n" +
"            topSort_DFS(i);\n" +
"    }\n" +
"    if(!ans.empty())\n" +
"    {\n" +
"        reverse(ans.begin(),ans.end());\n" +
"        cout << \"Topological Sort is :\\n\";\n" +
"        for(int i=0;i<ans.size();i++)\n" +
"            cout << ans[i] << \"->\";\n" +
"        cout << endl;\n" +
"    }\n" +
"}");
    }//GEN-LAST:event_topSortActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GraphTheory.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GraphTheory.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GraphTheory.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GraphTheory.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GraphTheory().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bellman;
    private javax.swing.JButton bfs;
    private javax.swing.JButton bpm;
    private javax.swing.JButton dfs;
    private javax.swing.JButton dijkstra;
    private javax.swing.JButton floyd;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton kruskal;
    private javax.swing.JTextArea output;
    private javax.swing.JButton prims;
    private javax.swing.JButton topSort;
    // End of variables declaration//GEN-END:variables
}
